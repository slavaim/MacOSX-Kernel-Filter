/* 
 * Copyright (c) 2010 Slava Imameev. All rights reserved.
 */

#include "DldDVDWhiteList.h"
#include "DldSupportingCode.h"
#include "iso9660.h"
#include "iso13346.h"
#include "udf.h"
#include "md5_hash.h"
#include "DldUserToKernel.h"
#include <IOKit/IOBufferMemoryDescriptor.h>
#include <IOKit/storage/IOCDBlockStorageDevice.h>
#include <IOKit/scsi/IOCompactDiscServices.h>
#include <IOKit/scsi/IODVDServices.h>
#include <IOKit/storage/IOCDTypes.h>
#include <IOKit/storage/IODVDTypes.h>

//--------------------------------------------------------------------

#define super OSObject

OSDefineMetaClassAndStructors( DldDVDWhiteList, OSObject )

//--------------------------------------------------------------------

#define PtrOffset(BASE,OFFSET) ((ULONG)((ULONG_PTR)(OFFSET) - (ULONG_PTR)(BASE)))

//--------------------------------------------------------------------

#define UNALIGNED

//
//  This macro copies an unaligned src longword to a dst longword,
//  performing an little/big endian swap.
//

#define SwapCopyUchar4(Dst,Src) {                                        \
*((UNALIGNED UCHAR *)(Dst)) = *((UNALIGNED UCHAR *)(Src) + 3);     \
*((UNALIGNED UCHAR *)(Dst) + 1) = *((UNALIGNED UCHAR *)(Src) + 2); \
*((UNALIGNED UCHAR *)(Dst) + 2) = *((UNALIGNED UCHAR *)(Src) + 1); \
*((UNALIGNED UCHAR *)(Dst) + 3) = *((UNALIGNED UCHAR *)(Src));     \
}

//--------------------------------------------------------------------

#define FIRST_CD_VD_SECTOR             (16)
#define CD_SECTOR_SIZE                 (2048)

//--------------------------------------------------------------------

//
// Number of elements in prime array must be a prime number, because 
// this number is used as a period in generating pseudo random sequence.
//
ULONG    g_Prime[ 61 ] = { 
    2,      3,      5,      7,      11,     13,     17,     19,
    23,     29,     31,     37,     41,     43,     47,     53,
    59,     61,     67,     71,     73,     79,     83,     89,
    97,     101,    103,    107,    109,    113,    127,    131,
    137,    139,    149,    151,    157,    163,    167,    173,
    179,    181,    191,    193,    197,    199,    211,    223,
    227,    229,    233,    239,    241,    251,    257,    263,
    269,    271,    277,    281,    283
};

#define AUTHENTIFICATION_READ_GRANULARITY_IN_SECTOR_UNITS ( 0x1400 )
#define SIZE_OF_PRIME_NUMBER_ARRAY    ( sizeof(g_Prime)/sizeof(g_Prime[0x0] ) )

//--------------------------------------------------------------------

static
void
GetPseudoRandomGeneratorParameters(
    __in ULONG      Initializer,
    __out PULONG    PtrM,
    __out PULONG    PtrA,
    __out PULONG    PtrC
    )
{
    assert( SIZE_OF_PRIME_NUMBER_ARRAY > 3 );
    //
    // Calculate numbers used to generate a pseudo random sequence.
    // Sequence is generated by using the formula X(n+1)=( a*X(n)+c ) mod( m )
    // in which "c" and "m" do not have common divisors.
    //
    (*PtrM) = SIZE_OF_PRIME_NUMBER_ARRAY;
    (*PtrC) = g_Prime[ Initializer%SIZE_OF_PRIME_NUMBER_ARRAY ];
    (*PtrA) = g_Prime[ ( Initializer + g_Prime[ Initializer%SIZE_OF_PRIME_NUMBER_ARRAY ] )%SIZE_OF_PRIME_NUMBER_ARRAY ];
    
    if( (*PtrC) == (*PtrM) )
        (*PtrC) = g_Prime[ SIZE_OF_PRIME_NUMBER_ARRAY - 0x2 ];
    
    if( (*PtrA) == (*PtrM) )
        (*PtrA) = g_Prime[ SIZE_OF_PRIME_NUMBER_ARRAY - 0x3 ];
    
}

//--------------------------------------------------------------------

DldDVDWhiteList*
DldDVDWhiteList::withDefaultSettings()
{
    DldDVDWhiteList*   newObject;
    
    newObject = new DldDVDWhiteList();
    assert( newObject );
    if( !newObject ){
        
        DBG_PRINT_ERROR(( "new DldDVDWhiteList() failed\n" ));
        return NULL;
    }
    
    if( !newObject->init() ){
        
        assert( !"new newObject->init() failed" );
        DBG_PRINT_ERROR(( "new newObject->init() failed\n" ));
        newObject->release();
        return NULL;
    }
    
    return newObject;
}

//--------------------------------------------------------------------

//
// the functions searches starting from the childObject parameter for a first object
// which is of or derived from the className class,
// the search is performed down the device stack ( i.e. to the root ),
// the returned object is referenced,
// the className must contain IOService on its inheritance path
//
IOService*
DldDVDWhiteList::referenceFirstObjectInStackByClassName(
    __in IOService*   startObject,
    __in const char*  className,
    __in TraversingDirection td
    )
{
    IOService*  foundObject;
    
    if( kTD_Any == td ){
        
        //
        // traverse the tree down and if unsuccessful traverse up
        //
        foundObject = DldDVDWhiteList::referenceFirstObjectInStackByClassName( startObject, className, kTD_Parent );// down
        if( !foundObject )
            foundObject = DldDVDWhiteList::referenceFirstObjectInStackByClassName( startObject, className, kTD_Child );// up
        
        return foundObject;
    }
    
	foundObject = static_cast<IOCDBlockStorageDevice*>(startObject->metaCast( className ));
	if( !foundObject ){
		
        //
		// This provider doesn't have the interface we need, so walk the
		// parents until we get one which does (usually only one or two objects)
        //
        
        OSIterator *	iterator = NULL;
		
        if( kTD_Parent == td ){
            iterator = startObject->getParentIterator ( gIOServicePlane );
        } else {
            assert( kTD_Child == td );
            iterator = startObject->getChildIterator ( gIOServicePlane );
        }

		if( iterator != NULL ){
			
			//DLD_COMM_LOG(( "Got to parent iterator\n" ));
			
            OSObject*   object   = NULL;
            
			while( NULL != (object = iterator->getNextObject()) ){
				
                //
                // break if we hit the root
                //
                if( NULL == OSDynamicCast( IOService, object ) )
                    break;
                
                //
				// Is it the interface we want?
                //
                
				foundObject = static_cast<IOService*>(object->metaCast( className ));
				//DLD_COMM_LOG(( "checking %s as a candidate for %s\n", ( (IOService*)object)->getName(), className ));
				if( foundObject ){
					
                    //
                    // retain the object before releasing the iterator
                    //
                    foundObject->retain();
					DLD_COMM_LOG ( DVD_WHITE_LIST, ( "Found %s\n", className ));
					break;
                    
				}
                
                //
                // traverse the tree recursively up or down, DFS
                // the returned object is retained
                //
                foundObject = DldDVDWhiteList::referenceFirstObjectInStackByClassName( OSDynamicCast( IOService, object ), className, td );
                if( foundObject ){
					
					DLD_COMM_LOG ( DVD_WHITE_LIST, ( "Found %s\n", className ));
					break;
                    
				}
				
                assert( !foundObject );
                
			}// end while
            
            //
            // foundObject has been retained if it has been found ( i.e. not NULL )
            //
            
            //
			// release the iterator, the iterator holds a reference to an object ( not necessary foundObject )
            //
			iterator->release();
			
			
		}// end if( iterator != NULL )
		
	} else {
        
        //
        // retain the object
        //
        foundObject->retain();
        
    }//end for else if( !foundObject )
    
    return foundObject;
}

//--------------------------------------------------------------------

IOReturn
DldDVDWhiteList::WIN_ProcessTocAndConvertToLbaInLittleEndian (
    __in    IOCDBlockStorageDevice*  device,
    __inout CDROM_TOC* CdromToc,
    __out   PULONG DiskFlags
    )
/*++
 
 Routine Description:
 
 This routine is called to verify and process the TOC for this disk and 
 convert all numbers in the TOC from a big-endian to a little-endian format,
 and converts all address in the LBA mode. ATTENTION! All addresses are in the 
 CdRom sector unit( 2048 bytes ).
 
 Arguments:
 
 TargetDeviceObject - Device object to send TOC request to.
 
 CdromToc - Pointer to TOC structure.
 
 DiskFlags - We return flags indicating what we know about the media.
 
 --*/
{
    IOReturn    RC;
    UInt16      actualByteCount = 0x0;
    ULONG       CurrentTrack;
    ULONG       LocalTrackCount;
    ULONG       LocalTocLength;
    
    union {
        
        UCHAR  LittleEndian[2];
        USHORT Length;
        
    } BiasedTocLength;
    
    assert( preemption_enabled() );
    
    bzero( CdromToc, sizeof( *CdromToc ) );
    
    //
    //  read the table of contents in the LBA format( not MSF )
    //
    
    RC = this->WIN_ReadTOC( device, 0x0, CdromToc, &actualByteCount );
    assert( kIOReturnSuccess == RC );
    if( kIOReturnSuccess != RC ){
        
        DBG_PRINT_ERROR(( "WIN_ReadTOC() failed with an error, RC = 0x%x\n", RC));
        
        //
        // tough luck
        //
        return RC;
        
    }// end if( kIOReturnSuccess != RC )
    
    //
    //  Get the number of tracks and stated size of this structure.
    //
    
    CurrentTrack = 0;
    LocalTrackCount = CdromToc->LastTrack - CdromToc->FirstTrack + 0x1;
    LocalTocLength = PtrOffset( CdromToc, &CdromToc->TrackData[LocalTrackCount + 1] );
    
    //
    //  Get out if there is an immediate problem with the TOC.
    //
    
    if( ( LocalTocLength > actualByteCount ) ||
        ( CdromToc->FirstTrack > CdromToc->LastTrack ) ){
        
        assert( !"a TOC failed the consistency check" );
        DBG_PRINT_ERROR(( "a TOC failed the consistency check\n" ));
        return kIOReturnBadMedia;
    }
    
    //
    // Walk through the individual tracks and the last track, 
    // which stands for the lead-out area of the last complete session, 
    // and convert fields.
    //
    
    while( CurrentTrack < ( LocalTrackCount + 0x1 ) ){
        
        PTRACK_DATA Track;
        
        //
        //  Get the next track.
        //
        
        Track = &CdromToc->TrackData[ CurrentTrack ];
        
        assert( !( TOC_LAST_TRACK == Track->TrackNumber && CurrentTrack < LocalTrackCount ) );
        
        //
        //  If this is a data track then check if we have only seen audio tracks
        //  to this point.
        //
        
        if( CurrentTrack != LocalTrackCount ){
            
            if( DlIsFlagOn( Track->Control, TOC_DATA_TRACK ) ) {
                
                //
                //  Set the flag to indicate data tracks present.
                //
                
                DlSetFlag( (*DiskFlags), CDROM_DISK_DATA_TRACK );
                
            } else {
                
                //
                //  If this is a audio track then set the flag indicating audio
                //  tracks.
                //
                
                DlSetFlag( (*DiskFlags), CDROM_DISK_AUDIO_TRACK );
                
            }
        }//if( CurrentTrack != LocalTrackCount )
        
            
        ULONG    Address;
        
        //
        // convert the start address from a big-endian to a little-endian format.
        //
        SwapCopyUchar4( &Address, &Track->Address);
        memcpy( &Track->Address, &Address, min( sizeof(Track->Address), sizeof( Address ) ) );
        
        //
        //  Set our index for the next track.
        //
        
        CurrentTrack += 1;
        
    }// end while( CurrentTrack < ( LocalTrackCount + 0x1 ) )
    
    //
    // return to the last( lead-out ) track
    //
    CurrentTrack = CurrentTrack - 0x1;
    
    //
    // set TOC_LAST_TRACK for the last entry Number
    //
    CdromToc->TrackData[ CurrentTrack ].TrackNumber = TOC_LAST_TRACK;
    
    //
    // calculate structure length
    //
    BiasedTocLength.Length = (USHORT)PtrOffset( CdromToc, &CdromToc->TrackData[CurrentTrack + 1] ) - 0x2;
    
    //
    // Set the TOC length in a little-endian format.
    //
    CdromToc->Length[0] = BiasedTocLength.LittleEndian[0];
    CdromToc->Length[1] = BiasedTocLength.LittleEndian[1];
    
    return RC;
}

//--------------------------------------------------------------------

IOReturn
DldDVDWhiteList::WIN_ReadTOC(
    __in    IOCDBlockStorageDevice*  device,
    __in    UInt8  formatAsTime,// 0x0 or 0x1 ( MSF bit set )
    __inout CDROM_TOC* toc,
    __out   UInt16*   actualByteCount
    )
{
    IOMemoryDescriptor *buffer;
    IOReturn RC;
    
    assert( preemption_enabled() );
    
    //
    // the memory provided by a caller is of the maximum required size,
    // an actual TOC might be less, see IOCDBlockStorageDriver::cacheTocInfo(void)
    // for the accurate TOC retrieval code
    //
    
    bzero( toc, sizeof( *toc ) );
    
    buffer = IOMemoryDescriptor::withAddress( toc, (IOByteCount)sizeof(*toc), kIODirectionIn );
    assert( buffer );
    if (buffer == NULL) {
        return kIOReturnNoMemory;
    }
    
    //
    // TO DO readTOC() with a single parameter has been declared depricated,
    // see
    // IOSCSIMultimediaCommandsDevice::ReadTOC ( IOMemoryDescriptor * buffer )
    // and 
    // IOSCSIMultimediaCommandsDevice::ReadTOC (
    //                      IOMemoryDescriptor *	buffer,
    //                      CDTOCFormat				format,
    //                      UInt8					msf,
    //                      UInt32					trackSessionNumber,
    //                      UInt16 *				actualByteCount )
    //
    
    
    RC = device->readTOC( buffer, kCDTOCFormatTOC, formatAsTime, 0x0, actualByteCount );
    
    //
    // The readTOC() should not fail for a CD media but can fail for a DVD one.
    // DVDs do not have a Table Of Contents like CDs do. They have Disc (neÃ© DVD) structures.
    // The reason is that they are different as defined by the SCSI MMC and Mt Fuji specs,
    // it seems that for some DVDs the system returns kCDMediaTypeUnknown, so exclude it from the mask
    //
#ifdef DBG
    UInt32   dbgMediaType;
    dbgMediaType = device->getMediaType();
    assert( kCDMediaTypeUnknown == dbgMediaType ||
            !(  0x0 == ( (~kCDMediaTypeMax) & dbgMediaType ) && kIOReturnSuccess != RC) );
#else
    assert( kCDMediaTypeUnknown == device->getMediaType() ||
            !(  0x0 == ( (~kCDMediaTypeMax) & device->getMediaType() ) && kIOReturnSuccess != RC) );
#endif
    if( kIOReturnSuccess != RC ){
        
        UInt32   mediaType;
        
        mediaType = device->getMediaType();
        
        // uncomment this, the GDB can't pass a macro definition
        DBG_PRINT_ERROR(( "device->readTOC() failed with an error for media type 0x%x, RC = 0x%x\n", (unsigned int)mediaType, RC));
        
        //
        // in that light if this is a DVD media we must build a TOC by hands
        //
        if( ( 0x0 == ( (~kDVDMediaTypeMax) & mediaType ) &&
              kDVDMediaTypeUnknown == ( kDVDMediaTypeUnknown & mediaType ) )
            || 
              kCDMediaTypeUnknown == mediaType ){
            
            //
            // at first we need a full disc size
            //
            UInt64   lastBlock;
            
            RC = device->reportMaxValidBlock( &lastBlock );
            assert( kIOReturnSuccess == RC );
            if( kIOReturnSuccess == RC ){
                
                //
                // forge a phony TOC similar to a Windows TOC
                /*
                 1: kd> dd 0xfffff980`0f528cd0
                 fffff980`0f528cd0  01011200 00011400 00000000 00aa1400
                 fffff980`0f528ce0  40052300 00000000 00000000 00000000
                 fffff980`0f528cf0  00000000 00000000 00000000 00000000
                 fffff980`0f528d00  00000000 00000000 00000000 00000000
                 fffff980`0f528d10  00000000 00000000 00000000 00000000
                 fffff980`0f528d20  00000000 00000000 00000000 00000000
                 fffff980`0f528d30  00000000 00000000 00000000 00000000
                 fffff980`0f528d40  00000000 00000000 00000000 00000000
                 1: kd> ??CdromToc
                 struct _CDROM_TOC * 0xfffff980`0f528cd0
                 +0x000 Length           : [2]  ""
                 +0x002 FirstTrack       : 0x1 ''
                 +0x003 LastTrack        : 0x1 ''
                 +0x004 TrackData        : [100] _TRACK_DATA
                 1: kd> ??CdromToc.TrackData[0]
                 Type is not struct/class/union for operator. '.TrackData[0]'
                 1: kd> ??CdromToc->TrackData[0]
                 struct _TRACK_DATA
                 +0x000 Reserved         : 0 ''
                 +0x001 Control          : 0y0100
                 +0x001 Adr              : 0y0001
                 +0x002 TrackNumber      : 0x1 ''
                 +0x003 Reserved1        : 0 ''
                 +0x004 Address          : [4]  ""
                 1: kd> ??*(ULONG)&CdromToc->TrackData[0].Address[0]
                 No pointer for operator* '<EOL>'
                 1: kd> ??*(ULONG*)&CdromToc->TrackData[0].Address[0]
                 unsigned long 0
                 1: kd> ??CdromToc->TrackData[1]
                 struct _TRACK_DATA
                 +0x000 Reserved         : 0 ''
                 +0x001 Control          : 0y0100
                 +0x001 Adr              : 0y0001
                 +0x002 TrackNumber      : 0xaa ''
                 +0x003 Reserved1        : 0 ''
                 +0x004 Address          : [4]  ""
                 1: kd> ??*(ULONG*)&CdromToc->TrackData[1].Address[0]
                 unsigned long 0x40052300 <- a big endian format
                 */
                //
                // a TOC is returned in the big endian format
                //
                toc->Length[1]   = 0x12;
                *actualByteCount = 0x12+0x2;//toc->Length doesn't account for itself
                assert( 0x0 == toc->Length[0] );
                
                toc->FirstTrack = 0x1;
                toc->LastTrack  = 0x1;
                
                //
                // fill in the first track
                //
                assert( 0x0 == toc->TrackData[0].Reserved );
                
                toc->TrackData[0].Control     = 0x4;
                toc->TrackData[0].Adr         = 0x1;
                toc->TrackData[0].TrackNumber = 0x1;
                assert( 0x0 == toc->TrackData[0].Reserved1 );
                assert( 0x0 == *(ULONG*)&toc->TrackData[0].Address[0] );
                
                //
                // fill in the last track ( a lead out area )
                //
                assert( 0x0 == toc->TrackData[1].Reserved );
                
                toc->TrackData[1].Control     = 0x4;
                toc->TrackData[1].Adr         = 0x1;
                toc->TrackData[1].TrackNumber = 0xAA;
                assert( 0x0 == toc->TrackData[1].Reserved1 );
                
                assert( lastBlock<0xFFFFFFFF );
                
                //
                // the invalid 0xAA track starts the next sector after reported as a max valid sector
                //
                lastBlock += 0x1;
                SwapCopyUchar4( (ULONG*)&toc->TrackData[1].Address[0], &lastBlock );
                
            } else {
                
                DBG_PRINT_ERROR(( "device->reportMaxValidBlock() failed for media type 0x%x, with an error RC = 0x%x\n", (unsigned int)mediaType, RC));
            }
            
        }
        
    } else { // else for if( kIOReturnSuccess != RC )
        
        //
        // a returned TOC might have an invalid very big last track address
        //

        UInt64   lastBlock;
        
        if( kIOReturnSuccess == device->reportMaxValidBlock( &lastBlock ) ){
            
            assert( toc->LastTrack < DLD_STATIC_ARRAY_SIZE( toc->TrackData ) );
            
            //
            // move to the boundary
            //
            lastBlock += 0x1;
            
            ULONG   tocLastBlock;
            SwapCopyUchar4( &tocLastBlock, (ULONG*)&toc->TrackData[ toc->LastTrack ].Address[0] );
            
            if( tocLastBlock > lastBlock ){

                SwapCopyUchar4( (ULONG*)&toc->TrackData[ toc->LastTrack ].Address[0], &lastBlock );
                
            } // if( tocLastBlock > lastBlock )
            
        } // end if( kIOReturnSuccess == device->reportMaxValidBlock( &lastBlock ) )
    }
    
    assert( kIOReturnSuccess == RC );
    
    buffer->release();
    return RC;
}

//--------------------------------------------------------------------
/*
IOReturn
IOCDBlockStorageDriver::reportDiscInfo(CDDiscInfo *discInfo)
{
    IOMemoryDescriptor *buffer;
    IOReturn result;
    UInt16 discInfoSize;
    
    bzero(discInfo,sizeof(CDDiscInfo));
    
    //Read the Disc Information in full: 
    
    buffer = IOMemoryDescriptor::withAddress(discInfo,sizeof(CDDiscInfo),kIODirectionIn);
    if (buffer == NULL) {
        return(kIOReturnNoMemory);
    }
    
    result = getProvider()->readDiscInfo(buffer,&discInfoSize);
    if (result != kIOReturnSuccess) {
        buffer->release();
        return(result);
    }
    
    buffer->release();
    
    // Reject the Disc Information if its size is too small: 
    
    if (discInfoSize < sizeof(CDDiscInfo)) {
        return(kIOReturnNotFound);
    }
    
    discInfoSize = OSSwapBigToHostInt16(discInfo->dataLength) + sizeof(discInfo->dataLength);
    
    if (discInfoSize < sizeof(CDDiscInfo)) {
        return(kIOReturnNotFound);
    }
    
    return(result);
}
*/
//--------------------------------------------------------------------

//
// the Windows counterpart interprets the values returned by SCSIOP_READ_CAPACITY( 0x25 ) cbd( see \src\storage\cdrom\cdrom.c ),
// on Mac OS X see IOSCSIMultimediaCommandsDevice::PollForMedia() for reference( look for READ_CAPACITY()-> kSCSICmd_READ_CAPACITY( 0x25 ) ),
// on Win see MediaReadCapacityDataInterpret() in /storage/class/cdrom/common.c for reference
//
IOReturn
DldDVDWhiteList::WIN_GetCdRomGeometry(
    __in    IOCDBlockStorageDevice*  device,
    __inout DISK_GEOMETRY*           ptrDiskGeometry
    )
{
    IOReturn   RC;
    
    bzero( ptrDiskGeometry, sizeof( *ptrDiskGeometry ) );
    
    UInt64 blockSize;
    RC = device->reportBlockSize( &blockSize );
    assert( kIOReturnSuccess == RC );
    if( kIOReturnSuccess != RC ){
     
        DBG_PRINT_ERROR(( "device->reportBlockSize() failed with an error, RC = 0x%x\n", RC));
        return RC;
    }
    
    //
    // for some reasons a 0x0 block size might be reported, for example search for ResetMediumCharacteristics()
    // in the Apple source code ( IOSCSIArchitectureModelFamily/IOSCSIArchitectureModelFamily-137.3.5/IOSCSIBlockCommands/IOSCSIBlockCommandsDevice.cpp )
    //
    if( 0x0 == blockSize ){
        
        RC = kIOReturnNoMedia;
        DBG_PRINT_ERROR(( "device->reportBlockSize() reported a zero block size, RC = 0x%x\n", RC));
        
        return RC;
    }
    
    ptrDiskGeometry->BytesPerSector = (DWORD)blockSize;
    assert( 0x0 != ptrDiskGeometry->BytesPerSector );
    
    //
    // MS has defaulted to 32/64 forever
    //
    ptrDiskGeometry->TracksPerCylinder = 0x40;
    ptrDiskGeometry->SectorsPerTrack   = 0x20;
    
    UInt64   lastBlock;
    RC = device->reportMaxValidBlock( &lastBlock );
    assert( kIOReturnSuccess == RC );
    if( kIOReturnSuccess != RC ){
        
        DBG_PRINT_ERROR(( "device->reportMaxValidBlock() failed with an error, RC = 0x%x\n", RC));
        return RC;
    }
    
    //
    // blocks are addressed starting at zero
    //
    ptrDiskGeometry->Cylinders.QuadPart = (LONGLONG)( (lastBlock+0x1)/(32*64) );
    ptrDiskGeometry->MediaType = RemovableMedia;
    
    return RC;
}

//--------------------------------------------------------------------

void
DldDVDWhiteList::asyncReadWriteCompletion(
    __in void *   target,
    __in void *   parameter,
    __in IOReturn status,
    __in UInt64   actualByteCount
    )
{
    wrCompletionData*     completionData = (wrCompletionData*)parameter;
    
#if DBG
    assert( WR_SIGN == completionData->signature );
#endif//DBG
    
    completionData->status          = status;
    completionData->actualByteCount = actualByteCount;
    
    //
    // wake up a waiting thread
    //
    DldSetNotificationEvent( &completionData->event );
}

//--------------------------------------------------------------------

IOReturn
DldDVDWhiteList::WIN_CdReadSectors(
    __out   PULONG     BytesRead,// for Windows an IoStatusBlock is here, not needed for Mac OS X as adds confusion
    __in    ULONGLONG  StartingOffset,
    __in    ULONG      ByteCount,
    __inout PVOID      Buffer,
    __in    IOCDBlockStorageDevice*  device,
    __in    bool       RawRead,
    __in    ULONG      BytesPerSector
    )
{
    IOReturn             RC;
    IOMemoryDescriptor*  buffer;
    
    //
    // we are going to wait
    //
    assert( preemption_enabled() );
    assert( !RawRead );// not yet supported
    
    buffer = IOMemoryDescriptor::withAddress( Buffer, (IOByteCount)ByteCount, kIODirectionIn );
    assert( buffer );
    if( !buffer )
        return kIOReturnNoMemory;
    
    IOStorageAttributes  attributes;
    IOStorageCompletion  completion;
    wrCompletionData     completionData;
    UInt64               block;
    UInt64               nblks;
    
    bzero( &attributes, sizeof( attributes ) );
    bzero( &completion, sizeof( completion ) );
    bzero( &completionData, sizeof( completionData ) );
    
    assert( 0x0 == StartingOffset%(ULONGLONG)BytesPerSector );
    assert( 0x0 == ByteCount%BytesPerSector );
    
    block = StartingOffset/(ULONGLONG)BytesPerSector;
    nblks = ByteCount/BytesPerSector;
    
#if DBG
    completionData.signature = WR_SIGN;
#endif//DBG
    DldInitNotificationEvent( &completionData.event );
    
    completion.target    = (void*)this;
    completion.action    = DldDVDWhiteList::asyncReadWriteCompletion;
    completion.parameter = &completionData;
    
    //
    // available starting from 10.5.0
    //
    RC = device->doAsyncReadWrite( buffer, block, nblks, &attributes, &completion);
    assert( kIOReturnSuccess == RC );
    if( kIOReturnSuccess == RC ){
        
        DldWaitForNotificationEvent( &completionData.event );
        
        RC         = completionData.status;
        *BytesRead = (ULONG)completionData.actualByteCount;
        
        assert( kIOReturnSuccess == RC );
        assert( *BytesRead == ByteCount );
        
    } else {
        
        DBG_PRINT_ERROR(( "device->doAsyncReadWrite() failed with an error, RC = 0x%x\n", RC));
        
    }// end !if( kIOReturnSuccess == RC )
    
    buffer->release();
    
    return RC;
}

//--------------------------------------------------------------------

IOReturn
DldDVDWhiteList::initCDDVDDiskID( 
    __in IOCDBlockStorageDevice*  device, 
    __inout CDDVDDiskID*  diskID 
    )
{
    IOReturn            RC;
    PVOID               RealBuffer = NULL;
    PVOID               CdSectorBuffer = NULL;
    PCDROM_TOC          CdRomToc = NULL;
    ULONG               CdTocLength = sizeof( *CdRomToc );
    ULONG               CdTocTrackCount;
    ULONG               CdTocDiskFlag = 0x0;
    MD5_CTX             md5_ctx;
    ULONG               CurrentTrack;
    ULONG               SectorSize;
    DISK_GEOMETRY*      PtrDiskGeometry = NULL;
    ULONGLONG           DiskSize = 0x0;
    ULARGE_INTEGER      DiskLastTrackFromTheDiskGeometry;
    bool                IsAudioCd;
    bool                IsLargeDisk = FALSE;
    int                 i;
    
    assert( preemption_enabled() );
    
    //
    // allocate memory for a CD TOC
    //
    
    CdRomToc = (PCDROM_TOC)IOMalloc( CdTocLength );
    assert( CdRomToc );
    if( NULL == CdRomToc ){
        
        RC = kIOReturnNoMemory;
        goto __exit;
    }
    
    bzero( CdRomToc, CdTocLength );
    
    //
    // read and process the CD TOC
    //
    
    RC = this->WIN_ProcessTocAndConvertToLbaInLittleEndian( device,
                                                            CdRomToc,
                                                            &CdTocDiskFlag );
    assert( kIOReturnSuccess == RC );
    if( kIOReturnSuccess != RC ){
     
        DBG_PRINT_ERROR(( "device->DldCdProcessTocAndConvertToLbaInLittleEndian() failed with an error, RC = 0x%x\n", RC));
        goto __exit;
    }
    
    CdTocTrackCount = CdRomToc->LastTrack - CdRomToc->FirstTrack + 1;
    
    PtrDiskGeometry = (DISK_GEOMETRY*)IOMalloc( sizeof( *PtrDiskGeometry ) );
    if( NULL == PtrDiskGeometry )
        goto __exit;
    
    RC = this->WIN_GetCdRomGeometry( device, PtrDiskGeometry );
    if( kIOReturnSuccess != RC ){
        
        DBG_PRINT_ERROR(( "device->WIN_GetCdRomGeometry() failed with an error, RC = 0x%x\n", RC));
        goto __exit;
    }
    
    DiskLastTrackFromTheDiskGeometry.QuadPart = (ULONGLONG)PtrDiskGeometry->SectorsPerTrack*
                                                (ULONGLONG)PtrDiskGeometry->TracksPerCylinder*
                                                (ULONGLONG)PtrDiskGeometry->Cylinders.QuadPart;
    
    assert( 0x0 == DiskLastTrackFromTheDiskGeometry.HighPart );
    
    //
    // check and change the returned TOC,
    // if the the track's address is greater than 
    // the DiskLastTrackFromTheDiskGeometry,
    // then set it to the DiskLastTrackFromTheDiskGeometry
    //
    CurrentTrack = 0x0;
    for( i = CurrentTrack; i<( CdTocTrackCount + 0x1 ); ++i ){
        
        if( *(PULONG)( &CdRomToc->TrackData[ i ].Address[ 0x0 ] ) > ( DiskLastTrackFromTheDiskGeometry.LowPart + 0x2000 ) ){
            
            *(PULONG)( &CdRomToc->TrackData[ i ].Address[ 0x0 ] ) = DiskLastTrackFromTheDiskGeometry.LowPart;
        }
        
    }//for( i = CurrentTrack; i<( CdTocTrackCount + 0x1 ); ++i )
    
    //
    // check the last entry, if it is zero set it to the valid value
    //
    if( *(PULONG)( &CdRomToc->TrackData[ CdTocTrackCount ].Address[ 0x0 ] ) == 0x0 ){
        
        *(PULONG)( &CdRomToc->TrackData[ CdTocTrackCount ].Address[ 0x0 ] ) = DiskLastTrackFromTheDiskGeometry.LowPart;
    }
    
    if( DlIsFlagOn( CdTocDiskFlag, CDROM_DISK_AUDIO_TRACK ) ){
        
        IsAudioCd = TRUE;
        SectorSize = RAW_SECTOR_SIZE;
        
    } else {
        
        IsAudioCd = FALSE;
        
        SectorSize = PtrDiskGeometry->BytesPerSector;
        assert( CD_SECTOR_SIZE == SectorSize );
        
        DiskSize = 0x0;
        /*
         DiskSize = ( (ULONGLONG)( (ULONGLONG)PtrDiskGeometry->BytesPerSector*(ULONGLONG)PtrDiskGeometry->SectorsPerTrack ) )*
         (ULONGLONG)PtrDiskGeometry->TracksPerCylinder*
         (ULONGLONG)PtrDiskGeometry->Cylinders.QuadPart;
         
         
         //
         // MSF is only capable of representing 256*(256+256*60)*75 = 0x11ce20 sectors.
         // This is 2.3gb, much less than the size of DVD media, which will respond to CDROM_TOC.
         // Windows 2000 returns TOC in the MSF format, therefore large disks can't be authenticated on it 
         // by using a TOC information.
         //
         */
        
        IsLargeDisk = DiskSize > ( ( (ULONGLONG)0x11ce20 ) * ( (ULONGLONG)CD_SECTOR_SIZE ) );
        
        //
        // TOC has been read in the LBA format, therefore all track's addresses are valid.
        //
        assert( FALSE == IsLargeDisk );
    }
    
    //
    // allocate memory for a sector buffer
    //
    
    RealBuffer = IOMalloc( 2*round_page( max( SectorSize, RAW_SECTOR_SIZE ) ) );
    assert( RealBuffer );
    if( NULL == RealBuffer )
        goto __exit;
    
    //
    // align on page boundary
    //
    
    CdSectorBuffer = (PVOID)round_page( RealBuffer );
    
    //
    // calculate hash
    //
    
    //
    // init hash
    //
    
    DldMD5Init( &md5_ctx );
    
    //
    // add the number of CD/DVD tracks to the hash
    //
    
    DldMD5Update( &md5_ctx, (unsigned char*)&CdTocTrackCount, sizeof( CdTocTrackCount ) );
    
    //
    // add CD/DVD flags to the hash
    //
    
    DldMD5Update( &md5_ctx, (unsigned char*)&CdTocDiskFlag, sizeof( CdTocDiskFlag ) );
    
    CurrentTrack = 0x0;
    
    if( FALSE == IsAudioCd ){
        
        PVSD_BEA01    PvsdBea01;
        ULONG         BytesToCompare;
        ULONG         BytesRead;
        
        //
        // Read the CD on an offset of 32 kb( 16th sector from zero ) where Primary Volume Descriptor is usually situated.
        // See RAW_ISO_VD for reference about buffer content in case of ISO 9660.
        //
        
        RC = this->WIN_CdReadSectors( &BytesRead, 
                                      FIRST_CD_VD_SECTOR*CD_SECTOR_SIZE,
                                      CD_SECTOR_SIZE, 
                                      CdSectorBuffer,
                                      device,
                                      FALSE,
                                      PtrDiskGeometry->BytesPerSector );
        
        assert( kIOReturnSuccess == RC );
        if( kIOReturnSuccess != RC ){
            
            DBG_PRINT_ERROR(( "device->WIN_CdReadSectors() failed with an error, RC = 0x%x\n", RC ));
            goto __exit;
        }
        
        //
        // add Primary Volume Descriptor in the hash
        //
        
        DldMD5Update( &md5_ctx, (unsigned char*)CdSectorBuffer, SectorSize );
        
        //
        // check whether this is a disk with UDF file system
        // in this case the files can be added to the disk without
        // influencing on the hash value, so some additional information
        // must be added to the hash
        // The algorithm is as follows( all interesting data are in little-endian format )
        //   1. Determine that this is a UDF file system by checking at 32 KB offset
        //      for Beginning Extended area Descriptor( BEA ), Volume Sequence Descriptor( VSD )
        //      with "NSR02" or "NSR03" signature and for Terminating Extended Area Descriptor( TEA )
        //   2. Get Anchor Volume Descriptor Pointer( AVDP ) at sector 256 ( for CD/DVD this is 
        //      0x80000 offset ), the tag is 0x2 at zero offset.
        //   3. From Anchor Volume Descriptor Pointer( AVDP ) get extent_ad for the Volume
        //      Descriptor Sequence( VDS ). The offset is in a sector units( 2 KB for CD/DVD ).
        //   4. VDS contains many descriptors each alligned on a sector boundary, the sequence
        //      is terminated either by Terminating Descriptor with 0x8 tag or by invalid sector.
        //      Find in VDS the Logical Volume Descriptor( LVD ) by the tag 0x6.
        //   5. The LVD containd ( at offset 0x1B0 ) the Integrity Sequence Extent in the form 
        //      of extent_ad which contains the address of the Logical Volume Integrity Descriptor( LVID ).
        //      The offset is in sector units.
        //   6. Add the Logical Volume Integrity Descriptor( LVID ) to the hash, the Logical Volume 
        //      Integrity Descriptor records the last time the media is written, so it is unlikely
        //      that this time will not change in case of writing if there is no cheating on user side.
        //
        
        PvsdBea01 = ( PVSD_BEA01 )CdSectorBuffer;
        BytesToCompare = min( sizeof( PvsdBea01->Ident ), sizeof( VSD_IDENT_BEA01 ) );
        //
        // start a UDF utilization
        //
        if( 0x0 == memcmp( PvsdBea01->Ident, VSD_IDENT_BEA01, BytesToCompare ) ){
            
            PVSD_GENERIC    PvsdGen;
            pudf_AnchorVolumeDescriptorPointer    PtrAnchVolDsc = NULL;
            pudf_LogicalVolumeDescriptor          PtrLogVolDsc = NULL;
            ULONG           LoopCounter = 0x0;
            ULONG           BytesRead;
            
            
            //
            // phase 1
            //
            
            //
            // read the VSD
            //
            RC = this->WIN_CdReadSectors( &BytesRead,  
                                    (FIRST_CD_VD_SECTOR+0x1)*SectorSize,
                                    SectorSize, 
                                    CdSectorBuffer,
                                    device,
                                    FALSE,
                                    PtrDiskGeometry->BytesPerSector );
            assert( kIOReturnSuccess == RC );
            if( kIOReturnSuccess != RC ){
                
                DBG_PRINT_ERROR(( "device->WIN_CdReadSectors() failed with an error, RC = 0x%x\n", RC ));
                goto __exit_udf;
            }
            
            PvsdGen = ( PVSD_GENERIC )CdSectorBuffer;
            BytesToCompare = min( sizeof( PvsdGen->Ident ), sizeof( VSD_IDENT_NSR02 ) );
            
            if( 0x0 != memcmp( PvsdGen->Ident, VSD_IDENT_NSR02, BytesToCompare ) &&
                0x0 != memcmp( PvsdGen->Ident, VSD_IDENT_NSR03, BytesToCompare ) )
                goto __exit_udf;
            
            //
            // phase 2
            //
            
            //
            // get the Anchor Volume Descriptor Pointer( AVDP ) at sector 256
            //
            RC = this->WIN_CdReadSectors( &BytesRead,
                                      UDF_AVDP_OFFSET_SECTOR*SectorSize,
                                      CD_SECTOR_SIZE, 
                                      CdSectorBuffer,
                                      device,
                                      FALSE,
                                      PtrDiskGeometry->BytesPerSector );
            assert( kIOReturnSuccess == RC );
            if( kIOReturnSuccess != RC ){
                
                DBG_PRINT_ERROR(( "device->WIN_CdReadSectors() failed with an error, RC = 0x%x\n", RC ));
                goto __exit_udf;
            }
            
            PtrAnchVolDsc = ( pudf_AnchorVolumeDescriptorPointer )CdSectorBuffer;
            
            //
            // phase 3 and 4
            //
            
            //
            // start the loop to retrieve the Logical Volume Descriptor( LVD ) from
            // VDS
            //
            LoopCounter = 0x0;
            while( LoopCounter < 0xFF){
                
                ULONGLONG       DescOffset = 0x0;
                pudf_tag        PtrDescTag;
                
                if( 0x0 == LoopCounter )
                    DescOffset = PtrAnchVolDsc->MainVolumeDescriptorSequenceExtent.ExtentLocation*SectorSize;
                else// PtrAnchVolDsc points to CdSectorBuffer which has been reused
                    DescOffset = DescOffset + SectorSize;
                
                RC = this->WIN_CdReadSectors( &BytesRead,
                                          DescOffset,
                                          SectorSize, 
                                          CdSectorBuffer,
                                          device,
                                          FALSE,
                                          PtrDiskGeometry->BytesPerSector );
                assert( kIOReturnSuccess == RC );
                if( kIOReturnSuccess != RC ){
                    
                    DBG_PRINT_ERROR(( "device->WIN_CdReadSectors() failed with an error, RC = 0x%x\n", RC ));
                    break;
                }
                
                PtrDescTag = ( pudf_tag )CdSectorBuffer;
                if( UDF_TD_TAG == PtrDescTag->TagIdentifier ){
                    
                    DBG_PRINT_ERROR(( "an invalid volume tag\n" ));
                    RC = kIOReturnBadMedia;
                    break;
                }
                
                if( UDF_LVD_TAG == PtrDescTag->TagIdentifier ){
                    
                    //
                    // the LVD has been found
                    //
                    PtrLogVolDsc = ( pudf_LogicalVolumeDescriptor )CdSectorBuffer;
                    
                    //
                    // exit the loop
                    //
                    break;
                    
                }
                
                ++LoopCounter;
                RC = kIOReturnBadMedia;
            }
            
            if( kIOReturnSuccess != RC )
                goto __exit_udf;
            
            assert( !PtrLogVolDsc );
            
            //
            // phase 5
            //
            RC = this->WIN_CdReadSectors( &BytesRead, 
                                      PtrLogVolDsc->IntegritySequenceExtent.ExtentLocation*SectorSize,
                                      SectorSize,
                                      CdSectorBuffer,
                                      device,
                                      FALSE,
                                      PtrDiskGeometry->BytesPerSector );
            assert( kIOReturnSuccess == RC );
            if( kIOReturnSuccess != RC ){
                
                DBG_PRINT_ERROR(( "device->WIN_CdReadSectors() failed with an error, RC = 0x%x\n", RC ));
                goto __exit_udf;
            }
            
            //
            // phase 6
            //
            DldMD5Update( &md5_ctx, (unsigned char*)CdSectorBuffer, SectorSize );
            
        __exit_udf: ;
        }
        
    } else {
        
        //
        // add track address for the audio CD
        //
        for( i = CurrentTrack; i<( CdTocTrackCount + 0x1 ); ++i ){
            
            DldMD5Update( &md5_ctx, (unsigned char*)CdRomToc->TrackData[ i ].Address, sizeof( CdRomToc->TrackData[ i ].Address ) );
        }
    }
    
    assert( TOC_LAST_TRACK == CdRomToc->TrackData[ CdTocTrackCount ].TrackNumber );
    
    assert( FALSE == IsLargeDisk );
    if( IsLargeDisk ){
        
        ULONGLONG         TrackLengthInSectorUnits;
        ULONGLONG         NumberOfControlSectors;
        ULONG             OldIndex = 0x0;
        ULONG             a,c,m;
        ULONGLONG         i;
        ULARGE_INTEGER    Initializer;
        ULONG             BluRayDivisor = 1;
        
        assert( FALSE == IsAudioCd );
        assert( 0x0 == DiskSize%SectorSize );
        
        TrackLengthInSectorUnits = DiskSize/SectorSize;
        
        if( DiskSize > ( 10ll*1024ll*1024ll*1024ll ) )
            BluRayDivisor = 10;
        
        NumberOfControlSectors = TrackLengthInSectorUnits/(AUTHENTIFICATION_READ_GRANULARITY_IN_SECTOR_UNITS*BluRayDivisor) + 0x1;
        
        assert( SIZE_OF_PRIME_NUMBER_ARRAY > 3 );
        //
        // Calculate numbers used to generate a pseudo random sequence.
        // Sequence is generated by using the formula X(n+1)=( a*X(n)+c ) mod( m )
        // in which "c" and "m" do not have common divisors.
        //
        Initializer.QuadPart = NumberOfControlSectors;
        GetPseudoRandomGeneratorParameters( Initializer.LowPart, &m, &a, &c );
        
        for( i = 0x0; i<NumberOfControlSectors; ++i ){
            
            ULONGLONG    ReadOffsetInSectorUnits;
            ULONG        IndexInPrimeArray;
            ULONG        BytesRead;
            
            //
            // generate pseudo random number
            //
            IndexInPrimeArray = ( a*OldIndex + c )%m;
            OldIndex = IndexInPrimeArray;
            
            assert( IndexInPrimeArray < SIZE_OF_PRIME_NUMBER_ARRAY );
#if DBG
            //DbgPrint( "DlDriver: Index in array of prime numbers 0x%X\n", IndexInPrimeArray );
#endif
            
            ReadOffsetInSectorUnits = ( BluRayDivisor*i*AUTHENTIFICATION_READ_GRANULARITY_IN_SECTOR_UNITS + g_Prime[ IndexInPrimeArray ] )%TrackLengthInSectorUnits;
            ReadOffsetInSectorUnits = ReadOffsetInSectorUnits + *(PULONG)&CdRomToc->TrackData[ CurrentTrack ].Address;
            
            bzero( CdSectorBuffer, SectorSize );
            
            RC = this->WIN_CdReadSectors( &BytesRead, 
                                          ReadOffsetInSectorUnits*PtrDiskGeometry->BytesPerSector,
                                          SectorSize, 
                                          CdSectorBuffer,
                                          device,
                                          FALSE,
                                          PtrDiskGeometry->BytesPerSector );
            
            if( kIOReturnSuccess != RC || BytesRead != SectorSize ){
                
                bzero( CdSectorBuffer, SectorSize );
            }
            RC = kIOReturnSuccess;
            /*
             continue;
             
             DLD_ASSERT( SectorSize == IoStatus.Information );
             
             if( IoStatus.Information != SectorSize )
             continue;*/
            
            //
            // add the sector in the hash
            //
            DldMD5Update( &md5_ctx, (unsigned char*)CdSectorBuffer, SectorSize );
            
        }//for( i = 0x0; i<NumberOfControlSectors; ++i )
        
    } else {
        
        //
        // read data from the disk in the pseudo random order
        //
        for( /*CurrentTrack*/ ; CurrentTrack < CdTocTrackCount; CurrentTrack = CurrentTrack + 0x1 ){
            
            ULONG        TrackLengthInSectorUnits;
            ULONG        NumberOfControlSectors;
            ULONG        OldIndex = 0x0;
            ULONG        a,c,m;
            ULONG        i;
            PTRACK_DATA PtrCurrentTrackData;
            bool         IsAudioTreck;
            ULONG        BytesPerTrackSector;
            ULONG        BluRayDivisor = 1;
            
            PtrCurrentTrackData = &CdRomToc->TrackData[ CurrentTrack ];
            TrackLengthInSectorUnits = *(PULONG)&( CdRomToc->TrackData[ CurrentTrack + 0x1 ].Address[0x0] ) - *(PULONG)&( PtrCurrentTrackData->Address[ 0x0 ] );
            
            if( 0x0 == TrackLengthInSectorUnits )
                continue;
            
            if( TrackLengthInSectorUnits > 0x500000 )
                BluRayDivisor = 10;
            
            NumberOfControlSectors = (ULONG)TrackLengthInSectorUnits/( BluRayDivisor*AUTHENTIFICATION_READ_GRANULARITY_IN_SECTOR_UNITS ) + 0x1;
            
            assert( SIZE_OF_PRIME_NUMBER_ARRAY > 3 );
            
            IsAudioTreck = ( false == DlIsFlagOn( PtrCurrentTrackData->Control, TOC_DATA_TRACK ) );
            
            if( IsAudioTreck )
                BytesPerTrackSector = RAW_SECTOR_SIZE;
            else
                BytesPerTrackSector = PtrDiskGeometry->BytesPerSector;
            
            //
            // skip an audio track as it doesn't use RS errors correction
            //
            if( IsAudioTreck )
                continue;
            
            //
            // Calculate numbers used to generate a pseudo random sequence.
            // Sequence is generated by using the formula X(n+1)=( a*X(n)+c ) mod( m )
            // in which "c" and "m" do not have common divisors.
            //
            GetPseudoRandomGeneratorParameters( NumberOfControlSectors, &m, &a, &c );
            
            for( i = 0x0; i<NumberOfControlSectors; ++i ){
                
                ULONG    ReadOffsetInSectorUnits;
                ULONG    IndexInPrimeArray;
                ULONG    ulRepeatCount = 0;
                ULONG    BytesRead;
                
                //
                // generate pseudo random number
                //
                IndexInPrimeArray = ( a*OldIndex + c )%m;
                OldIndex = IndexInPrimeArray;
                
                assert( IndexInPrimeArray < SIZE_OF_PRIME_NUMBER_ARRAY );
#if DBG
                //DbgPrint( "!! i is 0x%X\n", i );
                //DbgPrint( "DlDriver: Index in array of prime numbers 0x%X\n", IndexInPrimeArray );
#endif
                
                ReadOffsetInSectorUnits = ( BluRayDivisor*i*AUTHENTIFICATION_READ_GRANULARITY_IN_SECTOR_UNITS + g_Prime[ IndexInPrimeArray ] )%TrackLengthInSectorUnits;
                ReadOffsetInSectorUnits = ReadOffsetInSectorUnits + *(PULONG)&CdRomToc->TrackData[ CurrentTrack ].Address;
                
                bzero( CdSectorBuffer, SectorSize );
                
            check_once_more:
                
                RC = this->WIN_CdReadSectors( &BytesRead, 
                                          ReadOffsetInSectorUnits*PtrDiskGeometry->BytesPerSector,
                                          BytesPerTrackSector, 
                                          CdSectorBuffer,
                                          device,
                                          IsAudioTreck,
                                          PtrDiskGeometry->BytesPerSector );
                
                assert( kIOReturnSuccess == RC );
                if( kIOReturnSuccess != RC || BytesRead != SectorSize ){
                    
                    if( (++ulRepeatCount) < 0x3 )
                        goto check_once_more;
                    
                    bzero( CdSectorBuffer, SectorSize );
                }
                RC = kIOReturnSuccess;
                /*
                 if( !NT_SUCCESS( Status ) ){
                 
                 #if DBG
                 DbgPrint( "!! error reading sector 0x%X\n", ReadOffsetInSectorUnits );
                 #endif//DBG
                 continue;
                 }
                 DLD_ASSERT( BytesPerTrackSector == IoStatus.Information );
                 
                 if( IoStatus.Information != BytesPerTrackSector )
                 continue;
                 */
                
#if DBG
                {
                    PCHAR    RealBufferTest;
                    PCHAR    TestBuffer;
                    ULONG    BytesRead;
                    
                    RealBufferTest = (PCHAR)IOMalloc( 2*round_page( SectorSize ) );
                    assert( RealBufferTest );
                    if( RealBufferTest ){
                        
                        TestBuffer = (PCHAR)round_page( RealBufferTest );
                        
                        bzero( TestBuffer, SectorSize );
                        
                        RC = this->WIN_CdReadSectors( &BytesRead,
                                                  ReadOffsetInSectorUnits*PtrDiskGeometry->BytesPerSector,
                                                  BytesPerTrackSector, 
                                                  TestBuffer,
                                                  device,
                                                  IsAudioTreck,
                                                  PtrDiskGeometry->BytesPerSector );
                        
                        assert( kIOReturnSuccess == RC );
                        if( kIOReturnSuccess != RC || BytesRead != SectorSize ){
                            
                            bzero( TestBuffer, SectorSize );
                            RC = kIOReturnSuccess;
                        }
                        
                        if( kIOReturnSuccess == RC ){
                            
                            ULONG    i;
                            for( i = 0x0; i < BytesPerTrackSector; ++i ){
                                
                                if( TestBuffer[ i ] != ( (PCHAR)CdSectorBuffer )[ i ] ){
                                    
                                    DBG_PRINT_ERROR(( "DeviceLockDriver: Error in a check reading of a Cd Rom for a byte 0x%x in a sector 0x%x \n", (int)i, (int)ReadOffsetInSectorUnits));
                                }//if
                            }//for
                        }//if
                        
                        RC = kIOReturnSuccess;
                        IOFree( RealBufferTest, 2*round_page( SectorSize ) );
                    }//if( TestBuffer )
                }
#endif// DBG
                
                //
                // add the sector in the hash
                //
                DldMD5Update( &md5_ctx, (unsigned char*)CdSectorBuffer, BytesPerTrackSector );
            }//for( i = 0x0; i<NumberOfControlSectors; ++i )
            
        }//for( CurrentTrack ; CurrentTrack ... )]
        
    }//if( IsLargeDisk ) .. else ..
    
    DldMD5Final( &md5_ctx );
    
    assert( sizeof( CDDVDDiskID ) == sizeof( md5_ctx.digest ) ); 
    
    memcpy( diskID, md5_ctx.digest, sizeof( md5_ctx.digest ) );
    
#if DBG
    //
    // MS DVD
    //
    if( *(PULONG)&diskID[0x0] == 0x9d1b5582 &&
       *(PULONG)&diskID[0x4] == 0x89d49e57 &&
       *(PULONG)&diskID[0x8] == 0x72f32a9e &&
       *(PULONG)&diskID[0xC] == 0xa4ce1739 ){
        
    }
#endif
    
__exit:
    
    if( NULL != RealBuffer )
        IOFree( RealBuffer, 2*round_page( max( SectorSize, RAW_SECTOR_SIZE )  ) );
    
    if( NULL != PtrDiskGeometry )
        IOFree( PtrDiskGeometry, sizeof( *PtrDiskGeometry ) );
    
    if( NULL != CdRomToc )
        IOFree( CdRomToc, sizeof( *CdRomToc ) );
    
    return RC;
}

//--------------------------------------------------------------------

IOReturn
DldDVDWhiteList::getMediaUID(
    __in IOService* media,
    __inout CDDVDDiskID*  outDiskID
    )
{
    IOReturn             RC   = kIOReturnSuccess;
    
    assert( preemption_enabled() );
    
    DLD_COMM_LOG( DVD_WHITE_LIST, ("CD/DVD disk ID retrieving for 0x%p is started\n", media ));
    
    //
    // See if this object exports the IOCDBlockStorageDriver class,
    // use the cast by name to avoid linkage with the module
    // containing the IOCDBlockStorageDriver class,
    //
    // both IOCompactDiscServices and IODVDServices are attached to
    // the IOSCSIPeripheralDeviceType05 object derived from IOSCSIMultimediaCommandsDevice
    // and both are are derived from IOCDBlockStorageDevice,
    // the ioBlockInterface will be retained and must be released
    //
    // IOCDBlockStorageDriver is a class for an object attached to IODVDServices or 
    // IOCompactDiscServices class object
    //
    // I require two objects as I want to send requests at as low level as possible,
    // but some requests can't be issued at a very low level, for example
    // the IOSCSIMultimediaCommandsDevice::AsyncReadWrite uses the
    // IODVDServices::AsyncReadWriteComplete callback so can't be used
    // from the outside of the driver stack
    //
    IOCDBlockStorageDevice*   ioCDBlockStorageDevice = NULL;
    IOSCSIMultimediaCommandsDevice*  ioSCSIMultimediaCommandsDevice = NULL;
    
    ioCDBlockStorageDevice = static_cast<IOCDBlockStorageDevice*>( DldDVDWhiteList::referenceFirstObjectInStackByClassName( media, "IOCDBlockStorageDevice" ) );
    assert( ioCDBlockStorageDevice && ioCDBlockStorageDevice->metaCast( "IOCDBlockStorageDevice" ) );
    if( !ioCDBlockStorageDevice ){
        
        DBG_PRINT_ERROR(( "IOCDBlockStorageDevice is not in the stack for %s . CD/DVD style authorization is impossible\n",
                          ( (IOService*)media)->getName() ));
        
        //
        // return a success as it seems the media is not suitable for authorization
        // and in the first place the media should have not been authorized
        //
        assert( kIOReturnSuccess == RC );
        
        goto __exit;
    }
    
    ioSCSIMultimediaCommandsDevice = static_cast<IOSCSIMultimediaCommandsDevice*>( DldDVDWhiteList::referenceFirstObjectInStackByClassName( media, "IOSCSIMultimediaCommandsDevice" ) );
    assert( ioSCSIMultimediaCommandsDevice && ioSCSIMultimediaCommandsDevice->metaCast( "IOSCSIMultimediaCommandsDevice" ));
    if( !ioSCSIMultimediaCommandsDevice ){
        
        DBG_PRINT_ERROR(( "IOSCSIMultimediaCommandsDevice is not in the stack for %s . CD/DVD style authorization is impossible\n",
                         ( (IOService*)media)->getName() ));
        
        //
        // return a success as it seems the media is not suitable for authorization
        // and in the first place the media should have not been authorized
        //
        assert( kIOReturnSuccess == RC );
        
        goto __exit;
    }
    
    /*
    //
    // get the CD or DVD interface, no need to retain as
    // the ioBlockInterface object has been retained
    //
    IOCompactDiscServices*  ioCD;
    IODVDServices*          ioDVD;
    
    ioCD  = static_cast<IOCompactDiscServices*>(ioCDBlockStorageDevice->metaCast( "IOCompactDiscServices" ));
    ioDVD = static_cast<IODVDServices*>(ioCDBlockStorageDevice->metaCast( "IODVDServices" ));
    
    assert( ioCD || ioDVD );
    assert( !( ioCD && ioDVD ) );// only one is possible, not both
    
    if( !ioCD && !ioDVD ){
        
        DBG_PRINT_ERROR(( "Neither IOCompactDiscServices no IODVDServices are in the stack for %s . CD/DVD style authorization is impossible\n",
                         ( (IOService*)media)->getName() ));
        
        //
        // return a success as it seems the media is not suitable for authorization
        // and in the first place the media should have not been authorized
        //
        assert( kIOReturnSuccess == kernRet && 
                DldDVDWhiteList::AuthorizeStateUnknown == authState );
        
        goto __exit;
        
    }// end if( !ioCD && !ioDVD )
     */
    
    
    //
    // start the authorization
    //
    CDDVDDiskID  diskID;
    
    assert( sizeof( diskID ) == 16 );// a compiler compatibility check
    assert( sizeof( diskID ) == sizeof( DldDeviceUID ) );// a compiler compatibility check
    
    RC = initCDDVDDiskID( ioCDBlockStorageDevice, &diskID );
    assert( kIOReturnSuccess == RC || kIOReturnNoMedia == RC ); // kIOReturnNoMedia is okay if the access was disabled
    if( kIOReturnSuccess == RC ){
        
        memcpy( outDiskID, &diskID, sizeof( diskID ) );
        
        DLD_COMM_LOG( DVD_WHITE_LIST, ("CD/DVD disk ID for 0x%p is %08x:%08x:%08x:%08x\n",
                                       media,
                                       *(unsigned int*)&diskID.uid[0],
                                       *(unsigned int*)&diskID.uid[4],
                                       *(unsigned int*)&diskID.uid[8],
                                       *(unsigned int*)&diskID.uid[12] ) );
        
    }// end if( kIOReturnSuccess == RC )
	
__exit:
    
    if( ioCDBlockStorageDevice )
        ioCDBlockStorageDevice->release();
    
    if( ioSCSIMultimediaCommandsDevice )
        ioSCSIMultimediaCommandsDevice->release();
    
    DLD_COMM_LOG( DVD_WHITE_LIST, ("CD/DVD disk ID retrieving for 0x%p has completed with RC=0x%x\n", media, RC ));
    
    return RC;
}

//--------------------------------------------------------------------
